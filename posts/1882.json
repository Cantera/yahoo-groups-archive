{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":331418669,"authorName":"Ray Speth","from":"&quot;Ray Speth&quot; &lt;yarmond@...&gt;","profile":"yarmond","replyTo":"LIST","senderId":"06fJ8qzZqXz5Z9TEehDwV_vQX0BW3w-SKZT_XKZ3at11ZE-AnZp74QcM_PCWAMZ1mu9cvbSJcwjg8VlqBmxKfBtavdEvqQ","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Re: Thread safety of MultiTransport","postDate":"1206767433","msgId":1882,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGZza2owOSs3NDdmQGVHcm91cHMuY29tPg==","inReplyToHeader":"PGZzaDQ0aSt0NTVsQGVHcm91cHMuY29tPg=="},"prevInTopic":1881,"nextInTopic":0,"prevInTime":1881,"nextInTime":1883,"topicId":1862,"numMessagesInTopic":6,"msgSnippet":"I experience the same error when trying to compile Harry s code, or at least most of the time. Sometimes, the code completes, but about 1/4 of the","rawEmail":"Return-Path: &lt;yarmond@...&gt;\r\nX-Sender: yarmond@...\r\nX-Apparently-To: cantera@yahoogroups.com\r\nX-Received: (qmail 15323 invoked from network); 29 Mar 2008 05:10:33 -0000\r\nX-Received: from unknown (66.218.67.96)\n  by m54.grp.scd.yahoo.com with QMQP; 29 Mar 2008 05:10:33 -0000\r\nX-Received: from unknown (HELO n45b.bullet.mail.sp1.yahoo.com) (66.163.168.159)\n  by mta17.grp.scd.yahoo.com with SMTP; 29 Mar 2008 05:10:33 -0000\r\nX-Received: from [216.252.122.218] by n45.bullet.mail.sp1.yahoo.com with NNFMP; 29 Mar 2008 05:10:33 -0000\r\nX-Received: from [209.73.164.83] by t3.bullet.sp1.yahoo.com with NNFMP; 29 Mar 2008 05:10:33 -0000\r\nX-Received: from [66.218.66.76] by t7.bullet.scd.yahoo.com with NNFMP; 29 Mar 2008 05:10:33 -0000\r\nDate: Sat, 29 Mar 2008 05:10:33 -0000\r\nTo: cantera@yahoogroups.com\r\nMessage-ID: &lt;fskj09+747f@...&gt;\r\nIn-Reply-To: &lt;fsh44i+t55l@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0:0\r\nFrom: &quot;Ray Speth&quot; &lt;yarmond@...&gt;\r\nSubject: Re: Thread safety of MultiTransport\r\nX-Yahoo-Group-Post: member; u=331418669; y=fFOTJfPkguwMC5YmkH6ULaG3dXxQdHwIMYYzTSYXhMxxZw\r\nX-Yahoo-Profile: yarmond\r\n\r\nI experience the same error when trying to compile Harry&#39;s code, or at\nleas=\r\nt most of the time. Sometimes, the code completes, but about 1/4\nof the con=\r\nductivities returned are either NaN or negative.\n\nI&#39;ve also duplicated this=\r\n problem on a 32-bit linux box with both test\nprograms (running Ubuntu 7.10=\r\n). Here are the changes I made to my\nCantera preconfig script:\n\nCXXFLAGS=3D=\r\n${CXXFLAGS:=3D&quot;-O3 -Wall -fPIC&quot;}\nCFLAGS=3D${CFLAGS:=3D&quot;-fPIC&quot;}\nBUILD_THREAD=\r\n_SAFE=3D${BUILD_THREAD_SAFE:=3D&quot;y&quot;}\nBOOST_INC_DIR=3D${BOOST_INC_DIR:=3D&quot;/us=\r\nr/include/boost&quot;}\nBOOST_LIB_DIR=3D${BOOST_LIB_DIR:=3D&quot;/usr/lib&quot;}\nBOOST_THRE=\r\nAD_LIB=3D${BOOST_THREAD_LIB:=3D&quot;boost_thread-mt&quot;}\n\nThe options for the Make=\r\nfile to build the OpenMP code:\nCXX =3D g++-4.2\nCXX_FLAGS =3D -g -Wall  -I/u=\r\nsr/include/boost -fopenmp\nEXT_LIBS =3D  -luser -lkinetics -ltransport -lthe=\r\nrmo -lctnumerics\n-lctmath -ltpx -lctbase -lctlapack -lctblas -lctf2c -lboos=\r\nt_thread-mt\nLCXX_END_LIBS =3D -lm\nCANTERA_LIBDIR=3D/usr/local/cantera/lib\nC=\r\nANTERA_INCDIR=3D/usr/local/cantera/include\nLCXXFLAGS =3D -L$(CANTERA_LIBDIR=\r\n) -L/usr/local/lib -L/usr/lib -g -Wall\n\nFor the POSIX-thread based code, th=\r\ne options are the same except for\nremoving -fopenmp and adding -pthread to =\r\nCXX_FLAGS. On the 32-bit\nmachine, I was able to compile without adding -fPI=\r\nC to CXXFLAGS and\nCFLAGS.\n\nRay\n\n--- In cantera@yahoogroups.com, &quot;Ray Speth&quot;=\r\n &lt;yarmond@...&gt; wrote:\n&gt;\n&gt; Thanks for the replies. For the parts that I was =\r\nable to get working,\n&gt; I also noticed negligible performance improvements. =\r\nI wonder if this\n&gt; indicates that performance is mostly limited by memory a=\r\nccess speed.\n&gt; \n&gt; I have tried the example code I gave with the Intel C++ c=\r\nompiler under\n&gt; linux as well as in Windows with Visual Studio 2008, and en=\r\ncountered\n&gt; segfaults in both cases. In each case I recompiled Cantera usin=\r\ng the\n&gt; corresponding compiler. I haven&#39;t tried Harry&#39;s code yet to see if =\r\nI\n&gt; can get it working. Perhaps there&#39;s something wrong with my makefiles\n&gt;=\r\n for either Cantera or the demo program.\n&gt; \n&gt; Ray\n&gt; \n&gt; --- In cantera@yahoo=\r\ngroups.com, James Sutherland &lt;jamessuthe@&gt; wrote:\n&gt; &gt;\n&gt; &gt; All,\n&gt; &gt; \n&gt; &gt; I a=\r\nm not sure if my previous message went through or not.  I\n&gt; compiled and\n&gt; =\r\n&gt; ran the original code that Ray supplied on my Linux workstation (gcc\n&gt; 3.=\r\n4.x\n&gt; &gt; for Cantera and Boost::thread, pathscale for the supplied code). \nI=\r\nt ran\n&gt; &gt; fine on 1, 2, and 4 threads.\n&gt; &gt; \n&gt; &gt; As for scaling, I have seen=\r\n similar performance issues.  I have not\n&gt; found\n&gt; &gt; any speedups for threa=\r\nded parallelism on =B3small=B2 problems where\n&gt; threads do\n&gt; &gt; not perform =\r\nsignificant work during their lifetime.  This\n&gt; observation seems\n&gt; &gt; to ho=\r\nld for open MP as well as boost::thread (which is mainly a nice\n&gt; wrapper\n&gt;=\r\n &gt; around posix for a unix platform).  This observation was for both\n&gt; debu=\r\ng and\n&gt; &gt; optimized code and for both a Mac (dual core intel) and Linux (du=\r\nal\n&gt; &gt; processor, dual core intel chipset) desktop.  This observation is\n&gt; =\r\nnot unique\n&gt; &gt; to cantera applications.  I have other apps where similar sy=\r\nmptoms are\n&gt; &gt; manifest.\n&gt; &gt; \n&gt; &gt; I am not a thread guru either =AD so if a=\r\nnyone can shed additional\n&gt; light on\n&gt; &gt; the subject, I would appreciate it=\r\n as well.\n&gt; &gt; \n&gt; &gt; James\n&gt; &gt; \n&gt; &gt; \n&gt; &gt; On 3/26/08 4:44 PM, &quot;Moffat, Harry K=\r\n&quot; &lt;hkmoffa@&gt; wrote:\n&gt; &gt; \n&gt; &gt; &gt;  \n&gt; &gt; &gt;  \n&gt; &gt; &gt; \n&gt; &gt; &gt; Hi Ray,\n&gt; &gt; &gt;  I dupl=\r\nicated your example using a POSIX threads implementation\n&gt; (source code\n&gt; &gt;=\r\n &gt; enclosed). I didn&#39;t find any problems with MultiTransport from\n&gt; your di=\r\nrect\n&gt; &gt; &gt; example, but there were some issues.\n&gt; &gt; &gt; \n&gt; &gt; &gt; 1) I didn&#39;t fi=\r\nnd any speedup with using multiple threads\n&gt; unfortunately even\n&gt; &gt; &gt; thoug=\r\nh I&#39;m using a 2 cpu workstation with 2 cores per cpu ):. I\n&gt; wonder what\n&gt; =\r\n&gt; &gt; I&#39;m doing wrong.\n&gt; &gt; &gt; \n&gt; &gt; &gt; 2) I got a seg fault at the very end of t=\r\nhe application, iff I\n&gt; used more than\n&gt; &gt; &gt; 16 threads.\n&gt; &gt; &gt; \n&gt; &gt; &gt; 3) If=\r\n I called newTransport within the threads (see commented out\n&gt; code) rather=\r\n\n&gt; &gt; &gt; than setting up multiple MultiTransport objects before doing the\n&gt; p=\r\narallel\n&gt; &gt; &gt; pthreads implementation I ran into segfaults during newTransp=\r\nort.\n&gt; This is\n&gt; &gt; &gt; definately a multiple threads issue and needs to be lo=\r\noked into.\n&gt; &gt; &gt; \n&gt; &gt; &gt; I&#39;m new to multithreaded applications. Maybe someon=\r\ne could point\n&gt; out an issue\n&gt; &gt; &gt; with my approach. I did compile using gc=\r\nc and the -pthread\n&gt; compiler switch.\n&gt; &gt; &gt; Essentially I&#39;m following the a=\r\npproach from\n&gt; &gt; &gt;  https://computing.llnl.gov/tutorials/pthreads/#Thread\n&gt;=\r\n &gt; &gt; \n&gt; &gt; &gt; Best wishes,\n&gt; &gt; &gt; Harry\n&gt; &gt; &gt; \n&gt; &gt; &gt; #include &lt;stdio.h&gt;\n&gt; &gt; &gt; =\r\n#include &lt;stdlib.h&gt;\n&gt; &gt; &gt; #include &lt;pthread.h&gt;\n&gt; &gt; &gt; #include &lt;unistd.h&gt;\n&gt; =\r\n&gt; &gt; \n&gt; &gt; &gt; #include &lt;Cantera.h&gt;\n&gt; &gt; &gt; #include &lt;kernel/IdealGasPhase.h&gt;\n&gt; &gt;=\r\n &gt; #include &lt;transport.h&gt;\n&gt; &gt; &gt; #include &lt;thermo.h&gt;\n&gt; &gt; &gt; \n&gt; &gt; &gt; using name=\r\nspace Cantera;\n&gt; &gt; &gt; \n&gt; &gt; &gt; #define NUM_THREADS 8\n&gt; &gt; &gt; #define NUM_TEMPS 1=\r\n6*16\n&gt; &gt; &gt; \n&gt; &gt; &gt; struct pTran {\n&gt; &gt; &gt;  int iTemp;\n&gt; &gt; &gt;  ThermoPhase *tpBa=\r\nse;\n&gt; &gt; &gt;  TransportFactory *tfBase;\n&gt; &gt; &gt;  ThermoPhase *tpThread;\n&gt; &gt; &gt;  T=\r\nransport *p1Thread;\n&gt; &gt; &gt; };\n&gt; &gt; &gt; \n&gt; &gt; &gt; struct pTran ptran[NUM_THREADS];\n=\r\n&gt; &gt; &gt; std::vector&lt;double&gt; lambda(NUM_TEMPS, 0.0);\n&gt; &gt; &gt; \n&gt; &gt; &gt; // unsigned =\r\nlong\n&gt; &gt; &gt; pthread_t storID[NUM_THREADS];\n&gt; &gt; &gt; \n&gt; &gt; &gt; const pthread_attr_t=\r\n *att =3D 0;\n&gt; &gt; &gt; \n&gt; &gt; &gt; int gI =3D 0;\n&gt; &gt; &gt; void * startThread(void *rrr)=\r\n {\n&gt; &gt; &gt;  struct pTran *ppp =3D (struct pTran *) rrr;\n&gt; &gt; &gt;  //pthread_t si=\r\nd =3D pthread_self();\n&gt; &gt; &gt;  //printf(&quot;starting new thread %ld&#92;n&quot;, sid);\n&gt; =\r\n&gt; &gt;  // fflush(stdout);\n&gt; &gt; &gt;  //ThermoPhase *tp =3D (ppp-&gt;tpBase)-&gt;duplMys=\r\nelfAsThermoPhase();\n&gt; &gt; &gt;  //IdealGasPhase *thermoP =3D dynamic_cast &lt;Ideal=\r\nGasPhase *&gt; (tp);\n&gt; &gt; &gt;  //Transport *p1 =3D (ppp-&gt;tfBase)-&gt;newTransport(&quot;M=\r\nulti&quot;, thermoP);\n&gt; &gt; &gt; \n&gt; &gt; &gt; ThermoPhase *thermoP =3D ppp-&gt;tpThread;\n&gt; &gt; &gt;=\r\n  Transport *p1 =3D ppp-&gt;p1Thread;\n&gt; &gt; &gt; \n&gt; &gt; &gt; thermoP-&gt;setState_TPY(300.+=\r\n5. * (ppp-&gt;iTemp), OneAtm, &quot;N2:3.76,\n&gt; O2:1.0&quot;);\n&gt; &gt; &gt; \n&gt; &gt; &gt; lambda[ppp-&gt;i=\r\nTemp] =3D p1-&gt;thermalConductivity();\n&gt; &gt; &gt;  //delete p1;\n&gt; &gt; &gt;  //delete th=\r\nermoP;\n&gt; &gt; &gt;  pthread_exit((void *) 0);\n&gt; &gt; &gt; }\n&gt; &gt; &gt; \n&gt; &gt; &gt; int main(int a=\r\nrgc, void **argv) {\n&gt; &gt; &gt;  pthread_t storID[10];\n&gt; &gt; &gt;  void *    retnMsg[1=\r\n0];\n&gt; &gt; &gt;  pthread_t * ttt;\n&gt; &gt; &gt;  const pthread_attr_t * att =3D 0;\n&gt; &gt; &gt; =\r\n void *tArgs =3D 0;\n&gt; &gt; &gt;  tArgs =3D &gI;\n&gt; &gt; &gt;  bool doThreads =3D true;\n&gt;=\r\n &gt; &gt; \n&gt; &gt; &gt; XML_Node *xc =3D get_XML_File(&quot;gri30.xml&quot;);\n&gt; &gt; &gt;  XML_Node * c=\r\nonst xs =3D xc-&gt;findNameID(&quot;phase&quot;, &quot;gri30_multi&quot;);\n&gt; &gt; &gt; \n&gt; &gt; &gt; TransportF=\r\nactory * transFac =3D TransportFactory::factory();\n&gt; &gt; &gt;  ThermoPhase *tp =\r\n=3D newPhase(*xs);\n&gt; &gt; &gt;  for (int i =3D 0; i &lt; NUM_THREADS; i++) {\n&gt; &gt; &gt;  =\r\nstruct pTran *rrr =3D &ptran[i];\n&gt; &gt; &gt;  rrr-&gt;tpThread =3D tp-&gt;duplMyselfAsT=\r\nhermoPhase();\n&gt; &gt; &gt;  IdealGasPhase *thermoP =3D dynamic_cast &lt;IdealGasPhase=\r\n *&gt;\n&gt; (rrr-&gt;tpThread);\n&gt; &gt; &gt;  rrr-&gt;p1Thread =3D transFac-&gt;newTransport(&quot;Mul=\r\nti&quot;, thermoP);\n&gt; &gt; &gt;  }\n&gt; &gt; &gt; \n&gt; &gt; &gt; clockWC tickTock;\n&gt; &gt; &gt;  int jTemp =3D=\r\n 0;\n&gt; &gt; &gt;  do {\n&gt; &gt; &gt;  if (!doThreads) {\n&gt; &gt; &gt;  for (int i =3D 0; i &lt; NUM_T=\r\nHREADS; i++) {\n&gt; &gt; &gt;  ptran[i].iTemp =3D jTemp;\n&gt; &gt; &gt;  ptran[i].tpBase =3D =\r\ntp;\n&gt; &gt; &gt;  ptran[i].tfBase =3D transFac;\n&gt; &gt; &gt;  startThread((void *)&ptran[=\r\ni]);\n&gt; &gt; &gt;  jTemp++;\n&gt; &gt; &gt;  }\n&gt; &gt; &gt;  } else {\n&gt; &gt; &gt;  for (int i =3D 0; i &lt; =\r\nNUM_THREADS; i++) {\n&gt; &gt; &gt;  ptran[i].iTemp =3D jTemp;\n&gt; &gt; &gt;  ptran[i].tpBase=\r\n =3D tp;\n&gt; &gt; &gt;  ptran[i].tfBase =3D transFac;\n&gt; &gt; &gt; \n&gt; &gt; &gt; int en =3D pthre=\r\nad_create(&storID[i], att, &startThread, (void\n&gt; *)&ptran[i]);\n&gt; &gt; &gt;  if (e=\r\nn !=3D 0) {\n&gt; &gt; &gt;  printf(&quot;Error condition from pthread_create(): %d&#92;n&quot;, en=\r\n);\n&gt; &gt; &gt;  exit(-1);\n&gt; &gt; &gt;  }\n&gt; &gt; &gt;  //printf(&quot;new thead id =3D %ld&#92;n&quot;, stor=\r\nID[i]);\n&gt; &gt; &gt;  jTemp++;\n&gt; &gt; &gt;  }\n&gt; &gt; &gt;  }\n&gt; &gt; &gt;  if (doThreads) {\n&gt; &gt; &gt;  fo=\r\nr (int i =3D 0; i &lt; NUM_THREADS; i++) {\n&gt; &gt; &gt;  ttt =3D &storID[i];\n&gt; &gt; &gt;  i=\r\nnt rc =3D pthread_join(storID[i], &(retnMsg[i]));\n&gt; &gt; &gt;  if (rc !=3D 0) {\n&gt;=\r\n &gt; &gt;  printf(&quot;Error condition from pthread_jon(): %d&#92;n&quot;, rc);\n&gt; &gt; &gt;  exit(-=\r\n1);\n&gt; &gt; &gt;  }\n&gt; &gt; &gt;  //printf(&quot;returned from thread %ld&#92;n&quot;, storID[i]);\n&gt; &gt; =\r\n&gt;  }\n&gt; &gt; &gt;  }\n&gt; &gt; &gt; \n&gt; &gt; &gt; } while (jTemp &lt; NUM_TEMPS);\n&gt; &gt; &gt;  double tt =\r\n=3D tickTock.secondsWC();\n&gt; &gt; &gt; \n&gt; &gt; &gt; std::cout &lt;&lt; &quot;Thermal conductivities=\r\n as a function of\ntemperature:&#92;n&quot;;\n&gt; &gt; &gt;  for (int j =3D 0; j &lt;  NUM_TEMPS;=\r\n j++) {\n&gt; &gt; &gt;  std::cout &lt;&lt; 300.+5.*j &lt;&lt;&quot; &#92;t &quot; &lt;&lt; lambda[j] &lt;&lt; std::endl;\n&gt;=\r\n &gt; &gt;  }\n&gt; &gt; &gt;  printf(&quot;elapsed time =3D %g&#92;n&quot;, tt);\n&gt; &gt; &gt;  pthread_exit(NUL=\r\nL);\n&gt; &gt; &gt;  return 0;\n&gt; &gt; &gt; }\n&gt; &gt; &gt; \n&gt; &gt; &gt; Harry Moffat                     =\r\n                        (w) (505)\n&gt; 844-6912\n&gt; &gt; &gt; Nanoscale and Reactive P=\r\nrocesses            (f)   (505) 844-8251\n&gt; &gt; &gt; Sandia National Laboratories=\r\n\n&gt; &gt; &gt; hkmoffa@ &lt;mailto:hkmoffa%40sandia.gov&gt;\n&gt; &gt; &gt; P. O. Box 5800-0836\n&gt; &gt;=\r\n &gt; Albuquerque, NM 87185-0836\n&gt; &gt; &gt; \n&gt; &gt; &gt; -----Original Message-----\n&gt; &gt; &gt;=\r\n From: cantera@yahoogroups.com &lt;mailto:cantera%40yahoogroups.com&gt;\n&gt; &gt; &gt; [ma=\r\nilto:cantera@yahoogroups.com &lt;mailto:cantera%40yahoogroups.com&gt;\n&gt; ] On Beha=\r\nlf\n&gt; &gt; &gt; Of Ray Speth\n&gt; &gt; &gt; Sent: Saturday, March 22, 2008 1:25 PM\n&gt; &gt; &gt; To=\r\n: cantera@yahoogroups.com &lt;mailto:cantera%40yahoogroups.com&gt;\n&gt; &gt; &gt; Subject:=\r\n [cantera] Thread safety of MultiTransport\n&gt; &gt; &gt; \n&gt; &gt; &gt; Hi,\n&gt; &gt; &gt; \n&gt; &gt; &gt; I =\r\nhave been having some issues using objects of class\n&gt; MultiTransport in a\n&gt;=\r\n &gt; &gt; multithreaded application. Specifically, I am having trouble\nwith the\n=\r\n&gt; &gt; &gt; functions thermalConductivity and get thermalDiffCoeffs, which\n&gt; seem=\r\n to be the\n&gt; &gt; &gt; only two functions which involve calls to solveLMatrixEqua=\r\ntion.\nI have\n&gt; &gt; &gt; included below an example program that experiences the p=\r\nroblem.\n&gt; The error\n&gt; &gt; &gt; reported is (usually)\n&gt; &gt; &gt; \n&gt; &gt; &gt; terminate call=\r\ned after throwing an instance of\n&#39;Cantera::CanteraError&#39;\n&gt; &gt; &gt; \n&gt; &gt; &gt; If th=\r\ne call to omp_set_num_threads(2) is changed to\n&gt; omp_set_num_threads(1),\n&gt; =\r\n&gt; &gt; the program works fine. This is on a 64-bit Linux machine, using\n&gt; GCC =\r\n4.2. I\n&gt; &gt; &gt; have built Cantera with the Thread-safe option turned on. Is t=\r\nhe\n&gt; issue with\n&gt; &gt; &gt; these functions, or is there something else I need to=\r\n do to be\n&gt; able to use\n&gt; &gt; &gt; Multitransport objects in a parallel code?\n&gt; =\r\n&gt; &gt; \n&gt; &gt; &gt; Any help in resolving this would be greatly appreciated.\n&gt; &gt; &gt; \n=\r\n&gt; &gt; &gt; ----------\n&gt; &gt; &gt; \n&gt; &gt; &gt; #include &lt;cantera/Cantera.h&gt;\n&gt; &gt; &gt; #include &lt;=\r\ncantera/kernel/IdealGasPhase.h&gt; #include\n&gt; &lt;cantera/transport.h&gt;\n&gt; &gt; &gt; #inc=\r\nlude &lt;cantera/thermo.h&gt; #include &lt;omp.h&gt; #include &lt;vector&gt;\n&gt; &gt; &gt; \n&gt; &gt; &gt; usi=\r\nng namespace Cantera;\n&gt; &gt; &gt; \n&gt; &gt; &gt; void omptest(void)\n&gt; &gt; &gt; {\n&gt; &gt; &gt;  int N =\r\n=3D 10;\n&gt; &gt; &gt;  omp_set_num_threads(2);\n&gt; &gt; &gt; \n&gt; &gt; &gt; XML_Node *xc =3D get_XM=\r\nL_File(&quot;gri30.xml&quot;);\n&gt; &gt; &gt;  XML_Node * const xs =3D xc-&gt;findNameID(&quot;phase&quot;,=\r\n &quot;gri30_multi&quot;);\n&gt; &gt; &gt; \n&gt; &gt; &gt; std::vector&lt;IdealGasPhase*&gt; thermoP(N);\n&gt; &gt; &gt;=\r\n  std::vector&lt;MultiTransport*&gt; transportP(N);\n&gt; &gt; &gt; \n&gt; &gt; &gt; TransportFactory=\r\n* transFac =3D TransportFactory::factory();\n&gt; &gt; &gt; \n&gt; &gt; &gt; for (int i=3D0; i&lt;=\r\nN; i++) {\n&gt; &gt; &gt;  ThermoPhase* tp =3D newPhase(*xs);\n&gt; &gt; &gt;  thermoP[i] =3D d=\r\nynamic_cast &lt;IdealGasPhase*&gt;(tp);\n&gt; &gt; &gt;  Transport* p1 =3D transFac-&gt;newTra=\r\nnsport(&quot;Multi&quot;,thermoP[i]);\n&gt; &gt; &gt;  transportP[i] =3D dynamic_cast &lt;MultiTra=\r\nnsport*&gt;(p1);\n&gt; &gt; &gt;  }\n&gt; &gt; &gt; \n&gt; &gt; &gt; #pragma omp parallel for\n&gt; &gt; &gt;  for (in=\r\nt i=3D0; i&lt;N; i++) {\n&gt; &gt; &gt;  thermoP[i]-&gt;setState_TPY(300+50*i,OneAtm,&quot;N2:3.=\r\n76, O2:1.0&quot;);\n&gt; &gt; &gt;  }\n&gt; &gt; &gt; \n&gt; &gt; &gt; std::vector&lt;double&gt; lambda(N);\n&gt; &gt; &gt; \n&gt;=\r\n &gt; &gt; #pragma omp parallel for\n&gt; &gt; &gt;  for (int i=3D0; i&lt;N; i++) {\n&gt; &gt; &gt;  lam=\r\nbda[i] =3D transportP[i]-&gt;thermalConductivity();\n&gt; &gt; &gt;  }\n&gt; &gt; &gt; \n&gt; &gt; &gt; for =\r\n(int i=3D0; i&lt;N; i++) {\n&gt; &gt; &gt;  std::cout &lt;&lt; lambda[i] &lt;&lt; std::endl;\n&gt; &gt; &gt;  =\r\n}\n&gt; &gt; &gt; }\n&gt; &gt; &gt; \n&gt; &gt; &gt; int main(int argc, char** argv)\n&gt; &gt; &gt; {\n&gt; &gt; &gt;  try {=\r\n\n&gt; &gt; &gt;  omptest();\n&gt; &gt; &gt;  } catch (CanteraError) {\n&gt; &gt; &gt;  showErrors(cout);=\r\n\n&gt; &gt; &gt;  }\n&gt; &gt; &gt; }\n&gt; &gt; &gt; \n&gt; &gt; &gt; ------------------------------------\n&gt; &gt; &gt; \n=\r\n&gt; &gt; &gt; Yahoo! Groups Links\n&gt; &gt; &gt; \n&gt; &gt; &gt;  \n&gt; &gt; &gt;\n&gt; &gt;\n&gt;\n\n\n\n"}}