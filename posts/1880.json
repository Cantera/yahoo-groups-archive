{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":284669677,"authorName":"James Sutherland","from":"James Sutherland &lt;jamessuthe@...&gt;","profile":"jcs6a50","replyTo":"LIST","senderId":"k2FN1oVH79lCpXtIwyz5YTcX73K1Kh6vAy3fN1qs8mSFGAqVCY-5kXhVV03LXRdGkSgCjw0FicUL3IPQNefgze3OfH83VhHOfsjx8twq","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [cantera] Thread safety of MultiTransport","postDate":"1206583058","msgId":1880,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PEM0MTA1QjMyLjgzQTUlamFtZXNzdXRoZUBnbWFpbC5jb20+","inReplyToHeader":"PDI4RjgzMzQ3RTdFMUJENEU4Qzc4NTYwQjNCRTEzQjg1MEMxNUVERjYzOEBFUzAxU05MTlQuc3JuLnNhbmRpYS5nb3Y+"},"prevInTopic":1879,"nextInTopic":1881,"prevInTime":1879,"nextInTime":1881,"topicId":1862,"numMessagesInTopic":6,"msgSnippet":"All, I am not sure if my previous message went through or not.  I compiled and ran the original code that Ray supplied on my Linux workstation (gcc 3.4.x for","rawEmail":"Return-Path: &lt;jamessuthe@...&gt;\r\nX-Sender: jamessuthe@...\r\nX-Apparently-To: cantera@yahoogroups.com\r\nX-Received: (qmail 85846 invoked from network); 27 Mar 2008 01:57:48 -0000\r\nX-Received: from unknown (66.218.67.97)\n  by m53.grp.scd.yahoo.com with QMQP; 27 Mar 2008 01:57:48 -0000\r\nX-Received: from unknown (HELO wa-out-1112.google.com) (209.85.146.178)\n  by mta18.grp.scd.yahoo.com with SMTP; 27 Mar 2008 01:57:48 -0000\r\nX-Received: by wa-out-1112.google.com with SMTP id m38so4567208waf.5\n        for &lt;cantera@yahoogroups.com&gt;; Wed, 26 Mar 2008 18:57:48 -0700 (PDT)\r\nX-Received: by 10.114.146.1 with SMTP id t1mr544498wad.20.1206583068304;\n        Wed, 26 Mar 2008 18:57:48 -0700 (PDT)\r\nReturn-Path: &lt;jamessuthe@...&gt;\r\nX-Received: from ?192.168.1.4? ( [67.172.238.128])\n        by mx.google.com with ESMTPS id n37sm21607508wag.24.2008.03.26.18.57.42\n        (version=TLSv1/SSLv3 cipher=OTHER);\n        Wed, 26 Mar 2008 18:57:45 -0700 (PDT)\r\nUser-Agent: Microsoft-Entourage/11.4.0.080122\r\nDate: Wed, 26 Mar 2008 19:57:38 -0600\r\nTo: &lt;cantera@yahoogroups.com&gt;\r\nMessage-ID: &lt;C4105B32.83A5%jamessuthe@...&gt;\r\nThread-Topic: [cantera] Thread safety of MultiTransport\r\nThread-Index: AciMUmQambPGNVSmSweTUjLD/uN/RgDPllxwAAdMVmQ=\r\nIn-Reply-To: &lt;28F83347E7E1BD4E8C78560B3BE13B850C15EDF638@...&gt;\r\nMime-version: 1.0\r\nContent-type: multipart/alternative;\n\tboundary=&quot;B_3289406261_17003&quot;\r\nX-eGroups-Msg-Info: 1:12:0:0:0\r\nFrom: James Sutherland &lt;jamessuthe@...&gt;\r\nSubject: Re: [cantera] Thread safety of MultiTransport\r\nX-Yahoo-Group-Post: member; u=284669677; y=UkLcrREZe9jGRrmomB5Jp0zSF_6CXa-DI3Xkv6BjCk3rNQ\r\nX-Yahoo-Profile: jcs6a50\r\n\r\n\r\n--B_3289406261_17003\r\nContent-type: text/plain;\n\tcharset=&quot;ISO-8859-1&quot;\r\nContent-transfer-encoding: quoted-printable\r\n\r\nAll,\n\nI am not sure if my previous message went through or not.  I compiled=\r\n and\nran the original code that Ray supplied on my Linux workstation (gcc 3=\r\n.4.x\nfor Cantera and Boost::thread, pathscale for the supplied code).  It r=\r\nan\nfine on 1, 2, and 4 threads.\n\nAs for scaling, I have seen similar perfor=\r\nmance issues.  I have not found\nany speedups for threaded parallelism on =\r\n=B3small=B2 problems where threads do\nnot perform significant work during t=\r\nheir lifetime.  This observation seems\nto hold for open MP as well as boost=\r\n::thread (which is mainly a nice wrapper\naround posix for a unix platform).=\r\n  This observation was for both debug and\noptimized code and for both a Mac=\r\n (dual core intel) and Linux (dual\nprocessor, dual core intel chipset) desk=\r\ntop.  This observation is not unique\nto cantera applications.  I have other=\r\n apps where similar symptoms are\nmanifest.\n\nI am not a thread guru either =\r\n=AD so if anyone can shed additional light on\nthe subject, I would apprecia=\r\nte it as well.\n\nJames\n\n\nOn 3/26/08 4:44 PM, &quot;Moffat, Harry K&quot; &lt;hkmoffa@sand=\r\nia.gov&gt; wrote:\n\n&gt;  \n&gt;  \n&gt; \n&gt; Hi Ray,\n&gt;  I duplicated your example using a P=\r\nOSIX threads implementation (source code\n&gt; enclosed). I didn&#39;t find any pro=\r\nblems with MultiTransport from your direct\n&gt; example, but there were some i=\r\nssues.\n&gt; \n&gt; 1) I didn&#39;t find any speedup with using multiple threads unfort=\r\nunately even\n&gt; though I&#39;m using a 2 cpu workstation with 2 cores per cpu ):=\r\n. I wonder what\n&gt; I&#39;m doing wrong.\n&gt; \n&gt; 2) I got a seg fault at the very en=\r\nd of the application, iff I used more than\n&gt; 16 threads.\n&gt; \n&gt; 3) If I calle=\r\nd newTransport within the threads (see commented out code) rather\n&gt; than se=\r\ntting up multiple MultiTransport objects before doing the parallel\n&gt; pthrea=\r\nds implementation I ran into segfaults during newTransport. This is\n&gt; defin=\r\nately a multiple threads issue and needs to be looked into.\n&gt; \n&gt; I&#39;m new to=\r\n multithreaded applications. Maybe someone could point out an issue\n&gt; with =\r\nmy approach. I did compile using gcc and the -pthread compiler switch.\n&gt; Es=\r\nsentially I&#39;m following the approach from\n&gt;  https://computing.llnl.gov/tut=\r\norials/pthreads/#Thread\n&gt; \n&gt; Best wishes,\n&gt; Harry\n&gt; \n&gt; #include &lt;stdio.h&gt;\n&gt;=\r\n #include &lt;stdlib.h&gt;\n&gt; #include &lt;pthread.h&gt;\n&gt; #include &lt;unistd.h&gt;\n&gt; \n&gt; #inc=\r\nlude &lt;Cantera.h&gt;\n&gt; #include &lt;kernel/IdealGasPhase.h&gt;\n&gt; #include &lt;transport.=\r\nh&gt;\n&gt; #include &lt;thermo.h&gt;\n&gt; \n&gt; using namespace Cantera;\n&gt; \n&gt; #define NUM_THR=\r\nEADS 8\n&gt; #define NUM_TEMPS 16*16\n&gt; \n&gt; struct pTran {\n&gt;  int iTemp;\n&gt;  Therm=\r\noPhase *tpBase;\n&gt;  TransportFactory *tfBase;\n&gt;  ThermoPhase *tpThread;\n&gt;  T=\r\nransport *p1Thread;\n&gt; };\n&gt; \n&gt; struct pTran ptran[NUM_THREADS];\n&gt; std::vecto=\r\nr&lt;double&gt; lambda(NUM_TEMPS, 0.0);\n&gt; \n&gt; // unsigned long\n&gt; pthread_t storID[=\r\nNUM_THREADS];\n&gt; \n&gt; const pthread_attr_t *att =3D 0;\n&gt; \n&gt; int gI =3D 0;\n&gt; vo=\r\nid * startThread(void *rrr) {\n&gt;  struct pTran *ppp =3D (struct pTran *) rrr=\r\n;\n&gt;  //pthread_t sid =3D pthread_self();\n&gt;  //printf(&quot;starting new thread %=\r\nld&#92;n&quot;, sid);\n&gt;  // fflush(stdout);\n&gt;  //ThermoPhase *tp =3D (ppp-&gt;tpBase)-&gt;=\r\nduplMyselfAsThermoPhase();\n&gt;  //IdealGasPhase *thermoP =3D dynamic_cast &lt;Id=\r\nealGasPhase *&gt; (tp);\n&gt;  //Transport *p1 =3D (ppp-&gt;tfBase)-&gt;newTransport(&quot;Mu=\r\nlti&quot;, thermoP);\n&gt; \n&gt; ThermoPhase *thermoP =3D ppp-&gt;tpThread;\n&gt;  Transport *=\r\np1 =3D ppp-&gt;p1Thread;\n&gt; \n&gt; thermoP-&gt;setState_TPY(300.+5. * (ppp-&gt;iTemp), On=\r\neAtm, &quot;N2:3.76, O2:1.0&quot;);\n&gt; \n&gt; lambda[ppp-&gt;iTemp] =3D p1-&gt;thermalConductivi=\r\nty();\n&gt;  //delete p1;\n&gt;  //delete thermoP;\n&gt;  pthread_exit((void *) 0);\n&gt; }=\r\n\n&gt; \n&gt; int main(int argc, void **argv) {\n&gt;  pthread_t storID[10];\n&gt;  void * =\r\n   retnMsg[10];\n&gt;  pthread_t * ttt;\n&gt;  const pthread_attr_t * att =3D 0;\n&gt; =\r\n void *tArgs =3D 0;\n&gt;  tArgs =3D &gI;\n&gt;  bool doThreads =3D true;\n&gt; \n&gt; XML_=\r\nNode *xc =3D get_XML_File(&quot;gri30.xml&quot;);\n&gt;  XML_Node * const xs =3D xc-&gt;find=\r\nNameID(&quot;phase&quot;, &quot;gri30_multi&quot;);\n&gt; \n&gt; TransportFactory * transFac =3D Transp=\r\nortFactory::factory();\n&gt;  ThermoPhase *tp =3D newPhase(*xs);\n&gt;  for (int i =\r\n=3D 0; i &lt; NUM_THREADS; i++) {\n&gt;  struct pTran *rrr =3D &ptran[i];\n&gt;  rrr-&gt;=\r\ntpThread =3D tp-&gt;duplMyselfAsThermoPhase();\n&gt;  IdealGasPhase *thermoP =3D d=\r\nynamic_cast &lt;IdealGasPhase *&gt; (rrr-&gt;tpThread);\n&gt;  rrr-&gt;p1Thread =3D transFa=\r\nc-&gt;newTransport(&quot;Multi&quot;, thermoP);\n&gt;  }\n&gt; \n&gt; clockWC tickTock;\n&gt;  int jTemp=\r\n =3D 0;\n&gt;  do {\n&gt;  if (!doThreads) {\n&gt;  for (int i =3D 0; i &lt; NUM_THREADS; =\r\ni++) {\n&gt;  ptran[i].iTemp =3D jTemp;\n&gt;  ptran[i].tpBase =3D tp;\n&gt;  ptran[i].=\r\ntfBase =3D transFac;\n&gt;  startThread((void *)&ptran[i]);\n&gt;  jTemp++;\n&gt;  }\n&gt; =\r\n } else {\n&gt;  for (int i =3D 0; i &lt; NUM_THREADS; i++) {\n&gt;  ptran[i].iTemp =\r\n=3D jTemp;\n&gt;  ptran[i].tpBase =3D tp;\n&gt;  ptran[i].tfBase =3D transFac;\n&gt; \n&gt;=\r\n int en =3D pthread_create(&storID[i], att, &startThread, (void *)&ptran[i]=\r\n);\n&gt;  if (en !=3D 0) {\n&gt;  printf(&quot;Error condition from pthread_create(): %d=\r\n&#92;n&quot;, en);\n&gt;  exit(-1);\n&gt;  }\n&gt;  //printf(&quot;new thead id =3D %ld&#92;n&quot;, storID[i]=\r\n);\n&gt;  jTemp++;\n&gt;  }\n&gt;  }\n&gt;  if (doThreads) {\n&gt;  for (int i =3D 0; i &lt; NUM_T=\r\nHREADS; i++) {\n&gt;  ttt =3D &storID[i];\n&gt;  int rc =3D pthread_join(storID[i],=\r\n &(retnMsg[i]));\n&gt;  if (rc !=3D 0) {\n&gt;  printf(&quot;Error condition from pthrea=\r\nd_jon(): %d&#92;n&quot;, rc);\n&gt;  exit(-1);\n&gt;  }\n&gt;  //printf(&quot;returned from thread %l=\r\nd&#92;n&quot;, storID[i]);\n&gt;  }\n&gt;  }\n&gt; \n&gt; } while (jTemp &lt; NUM_TEMPS);\n&gt;  double tt =\r\n=3D tickTock.secondsWC();\n&gt; \n&gt; std::cout &lt;&lt; &quot;Thermal conductivities as a fu=\r\nnction of temperature:&#92;n&quot;;\n&gt;  for (int j =3D 0; j &lt;  NUM_TEMPS; j++) {\n&gt;  s=\r\ntd::cout &lt;&lt; 300.+5.*j &lt;&lt;&quot; &#92;t &quot; &lt;&lt; lambda[j] &lt;&lt; std::endl;\n&gt;  }\n&gt;  printf(&quot;e=\r\nlapsed time =3D %g&#92;n&quot;, tt);\n&gt;  pthread_exit(NULL);\n&gt;  return 0;\n&gt; }\n&gt; \n&gt; Ha=\r\nrry Moffat                                             (w) (505) 844-6912\n&gt;=\r\n Nanoscale and Reactive Processes            (f)   (505) 844-8251\n&gt; Sandia =\r\nNational Laboratories\n&gt; hkmoffa@... &lt;mailto:hkmoffa%40sandia.gov&gt;\n&gt; =\r\nP. O. Box 5800-0836\n&gt; Albuquerque, NM 87185-0836\n&gt; \n&gt; -----Original Message=\r\n-----\n&gt; From: cantera@yahoogroups.com &lt;mailto:cantera%40yahoogroups.com&gt;\n&gt; =\r\n[mailto:cantera@yahoogroups.com &lt;mailto:cantera%40yahoogroups.com&gt; ] On Beh=\r\nalf\n&gt; Of Ray Speth\n&gt; Sent: Saturday, March 22, 2008 1:25 PM\n&gt; To: cantera@y=\r\nahoogroups.com &lt;mailto:cantera%40yahoogroups.com&gt;\n&gt; Subject: [cantera] Thre=\r\nad safety of MultiTransport\n&gt; \n&gt; Hi,\n&gt; \n&gt; I have been having some issues us=\r\ning objects of class MultiTransport in a\n&gt; multithreaded application. Speci=\r\nfically, I am having trouble with the\n&gt; functions thermalConductivity and g=\r\net thermalDiffCoeffs, which seem to be the\n&gt; only two functions which invol=\r\nve calls to solveLMatrixEquation. I have\n&gt; included below an example progra=\r\nm that experiences the problem. The error\n&gt; reported is (usually)\n&gt; \n&gt; term=\r\ninate called after throwing an instance of &#39;Cantera::CanteraError&#39;\n&gt; \n&gt; If =\r\nthe call to omp_set_num_threads(2) is changed to omp_set_num_threads(1),\n&gt; =\r\nthe program works fine. This is on a 64-bit Linux machine, using GCC 4.2. I=\r\n\n&gt; have built Cantera with the Thread-safe option turned on. Is the issue w=\r\nith\n&gt; these functions, or is there something else I need to do to be able t=\r\no use\n&gt; Multitransport objects in a parallel code?\n&gt; \n&gt; Any help in resolvi=\r\nng this would be greatly appreciated.\n&gt; \n&gt; ----------\n&gt; \n&gt; #include &lt;canter=\r\na/Cantera.h&gt;\n&gt; #include &lt;cantera/kernel/IdealGasPhase.h&gt; #include &lt;cantera/=\r\ntransport.h&gt;\n&gt; #include &lt;cantera/thermo.h&gt; #include &lt;omp.h&gt; #include &lt;vecto=\r\nr&gt;\n&gt; \n&gt; using namespace Cantera;\n&gt; \n&gt; void omptest(void)\n&gt; {\n&gt;  int N =3D 1=\r\n0;\n&gt;  omp_set_num_threads(2);\n&gt; \n&gt; XML_Node *xc =3D get_XML_File(&quot;gri30.xml=\r\n&quot;);\n&gt;  XML_Node * const xs =3D xc-&gt;findNameID(&quot;phase&quot;, &quot;gri30_multi&quot;);\n&gt; \n&gt;=\r\n std::vector&lt;IdealGasPhase*&gt; thermoP(N);\n&gt;  std::vector&lt;MultiTransport*&gt; tr=\r\nansportP(N);\n&gt; \n&gt; TransportFactory* transFac =3D TransportFactory::factory(=\r\n);\n&gt; \n&gt; for (int i=3D0; i&lt;N; i++) {\n&gt;  ThermoPhase* tp =3D newPhase(*xs);\n&gt;=\r\n  thermoP[i] =3D dynamic_cast &lt;IdealGasPhase*&gt;(tp);\n&gt;  Transport* p1 =3D tr=\r\nansFac-&gt;newTransport(&quot;Multi&quot;,thermoP[i]);\n&gt;  transportP[i] =3D dynamic_cast=\r\n &lt;MultiTransport*&gt;(p1);\n&gt;  }\n&gt; \n&gt; #pragma omp parallel for\n&gt;  for (int i=3D=\r\n0; i&lt;N; i++) {\n&gt;  thermoP[i]-&gt;setState_TPY(300+50*i,OneAtm,&quot;N2:3.76, O2:1.0=\r\n&quot;);\n&gt;  }\n&gt; \n&gt; std::vector&lt;double&gt; lambda(N);\n&gt; \n&gt; #pragma omp parallel for\n=\r\n&gt;  for (int i=3D0; i&lt;N; i++) {\n&gt;  lambda[i] =3D transportP[i]-&gt;thermalCondu=\r\nctivity();\n&gt;  }\n&gt; \n&gt; for (int i=3D0; i&lt;N; i++) {\n&gt;  std::cout &lt;&lt; lambda[i] =\r\n&lt;&lt; std::endl;\n&gt;  }\n&gt; }\n&gt; \n&gt; int main(int argc, char** argv)\n&gt; {\n&gt;  try {\n&gt; =\r\n omptest();\n&gt;  } catch (CanteraError) {\n&gt;  showErrors(cout);\n&gt;  }\n&gt; }\n&gt; \n&gt; =\r\n------------------------------------\n&gt; \n&gt; Yahoo! Groups Links\n&gt; \n&gt;  \n&gt;     =\r\n\n\n\n\r\n--B_3289406261_17003\r\nContent-type: text/html;\n\tcharset=&quot;ISO-8859-1&quot;\r\nContent-transfer-encoding: quoted-printable\r\n\r\n&lt;HTML&gt;\n&lt;HEAD&gt;\n&lt;TITLE&gt;Re: [cantera] Thread safety of MultiTransport&lt;/TITLE&gt;\n=\r\n&lt;/HEAD&gt;\n&lt;BODY&gt;\n&lt;FONT FACE=3D&quot;Verdana, Helvetica, Arial&quot;&gt;&lt;SPAN STYLE=3D&#39;font=\r\n-size:12.0px&#39;&gt;All,&lt;BR&gt;\n&lt;BR&gt;\nI am not sure if my previous message went throu=\r\ngh or not. &nbsp;I compiled and ran the original code that Ray supplied on =\r\nmy Linux workstation (gcc 3.4.x for Cantera and Boost::thread, pathscale fo=\r\nr the supplied code). &nbsp;It ran fine on 1, 2, and 4 threads.&lt;BR&gt;\n&lt;BR&gt;\nAs=\r\n for scaling, I have seen similar performance issues. &nbsp;I have not foun=\r\nd any speedups for threaded parallelism on &#8220;small&#8221; problems whe=\r\nre threads do not perform significant work during their lifetime. &nbsp;Thi=\r\ns observation seems to hold for open MP as well as boost::thread (which is =\r\nmainly a nice wrapper around posix for a unix platform). &nbsp;This observa=\r\ntion was for both debug and optimized code and for both a Mac (dual core in=\r\ntel) and Linux (dual processor, dual core intel chipset) desktop. &nbsp;Thi=\r\ns observation is not unique to cantera applications. &nbsp;I have other app=\r\ns where similar symptoms are manifest.&lt;BR&gt;\n&lt;BR&gt;\nI am not a thread guru eith=\r\ner &#8211; so if anyone can shed additional light on the subject, I would a=\r\nppreciate it as well.&lt;BR&gt;\n&lt;BR&gt;\nJames&lt;BR&gt;\n&lt;BR&gt;\n&lt;BR&gt;\nOn 3/26/08 4:44 PM, &quo=\r\nt;Moffat, Harry K&quot; &lt;hkmoffa@...&gt; wrote:&lt;BR&gt;\n&lt;BR&gt;\n&lt;/SPAN&gt;&lt;=\r\n/FONT&gt;&lt;BLOCKQUOTE&gt;&lt;FONT FACE=3D&quot;Verdana, Helvetica, Arial&quot;&gt;&lt;SPAN STYLE=3D&#39;f=\r\nont-size:12.0px&#39;&gt; &lt;BR&gt;\n&nbsp;&lt;BR&gt;\n&lt;BR&gt;\nHi Ray,&lt;BR&gt;\n&nbsp;I duplicated your =\r\nexample using a POSIX threads implementation (source code enclosed). I didn=\r\n&#39;t find any problems with MultiTransport from your direct example, but ther=\r\ne were some issues.&lt;BR&gt;\n&lt;BR&gt;\n1) I didn&#39;t find any speedup with using multip=\r\nle threads unfortunately even though I&#39;m using a 2 cpu workstation with 2 c=\r\nores per cpu ):. I wonder what I&#39;m doing wrong.&lt;BR&gt;\n&lt;BR&gt;\n2) I got a seg fau=\r\nlt at the very end of the application, iff I used more than 16 threads.&lt;BR&gt;=\r\n\n&lt;BR&gt;\n3) If I called newTransport within the threads (see commented out cod=\r\ne) rather than setting up multiple MultiTransport objects before doing the =\r\nparallel pthreads implementation I ran into segfaults during newTransport. =\r\nThis is definately a multiple threads issue and needs to be looked into.&lt;BR=\r\n&gt;\n&lt;BR&gt;\nI&#39;m new to multithreaded applications. Maybe someone could point out=\r\n an issue with my approach. I did compile using gcc and the -pthread compil=\r\ner switch. Essentially I&#39;m following the approach from&lt;BR&gt;\n&nbsp;https://co=\r\nmputing.llnl.gov/tutorials/pthreads/#Thread&lt;BR&gt;\n&lt;BR&gt;\nBest wishes,&lt;BR&gt;\nHarry=\r\n&lt;BR&gt;\n&lt;BR&gt;\n#include &lt;stdio.h&gt;&lt;BR&gt;\n#include &lt;stdlib.h&gt;&lt;BR&gt;\n#inclu=\r\nde &lt;pthread.h&gt;&lt;BR&gt;\n#include &lt;unistd.h&gt;&lt;BR&gt;\n&lt;BR&gt;\n#include &lt;Ca=\r\nntera.h&gt;&lt;BR&gt;\n#include &lt;kernel/IdealGasPhase.h&gt;&lt;BR&gt;\n#include &lt;tr=\r\nansport.h&gt;&lt;BR&gt;\n#include &lt;thermo.h&gt;&lt;BR&gt;\n&lt;BR&gt;\nusing namespace Canter=\r\na;&lt;BR&gt;\n&lt;BR&gt;\n#define NUM_THREADS 8&lt;BR&gt;\n#define NUM_TEMPS 16*16&lt;BR&gt;\n&lt;BR&gt;\nstru=\r\nct pTran {&lt;BR&gt;\n&nbsp;int iTemp;&lt;BR&gt;\n&nbsp;ThermoPhase *tpBase;&lt;BR&gt;\n&nbsp;Tr=\r\nansportFactory *tfBase;&lt;BR&gt;\n&nbsp;ThermoPhase *tpThread;&lt;BR&gt;\n&nbsp;Transpor=\r\nt *p1Thread;&lt;BR&gt;\n};&lt;BR&gt;\n&lt;BR&gt;\nstruct pTran ptran[NUM_THREADS];&lt;BR&gt;\nstd::vect=\r\nor&lt;double&gt; lambda(NUM_TEMPS, 0.0);&lt;BR&gt;\n&lt;BR&gt;\n// unsigned long&lt;BR&gt;\npthr=\r\nead_t storID[NUM_THREADS];&lt;BR&gt;\n&lt;BR&gt;\nconst pthread_attr_t *att =3D 0;&lt;BR&gt;\n&lt;B=\r\nR&gt;\nint gI =3D 0;&lt;BR&gt;\nvoid * startThread(void *rrr) {&lt;BR&gt;\n&nbsp;struct pTran=\r\n *ppp =3D (struct pTran *) rrr;&lt;BR&gt;\n&nbsp;//pthread_t sid =3D pthread_self(=\r\n);&lt;BR&gt;\n&nbsp;//printf(&quot;starting new thread %ld&#92;n&quot;, sid);&lt;BR&gt;\n&nbs=\r\np;// fflush(stdout);&lt;BR&gt;\n&nbsp;//ThermoPhase *tp =3D (ppp-&gt;tpBase)-&gt;d=\r\nuplMyselfAsThermoPhase();&lt;BR&gt;\n&nbsp;//IdealGasPhase *thermoP =3D dynamic_ca=\r\nst &lt;IdealGasPhase *&gt; (tp);&lt;BR&gt;\n&nbsp;//Transport *p1 =3D (ppp-&gt;tfB=\r\nase)-&gt;newTransport(&quot;Multi&quot;, thermoP);&lt;BR&gt;\n&lt;BR&gt;\nThermoPhase *th=\r\nermoP =3D ppp-&gt;tpThread;&lt;BR&gt;\n&nbsp;Transport *p1 =3D ppp-&gt;p1Thread;&lt;B=\r\nR&gt;\n&lt;BR&gt;\nthermoP-&gt;setState_TPY(300.+5. * (ppp-&gt;iTemp), OneAtm, &quot;N=\r\n2:3.76, O2:1.0&quot;);&lt;BR&gt;\n&lt;BR&gt;\nlambda[ppp-&gt;iTemp] =3D p1-&gt;thermalCon=\r\nductivity();&lt;BR&gt;\n&nbsp;//delete p1;&lt;BR&gt;\n&nbsp;//delete thermoP;&lt;BR&gt;\n&nbsp;p=\r\nthread_exit((void *) 0);&lt;BR&gt;\n}&lt;BR&gt;\n&lt;BR&gt;\nint main(int argc, void **argv) {&lt;B=\r\nR&gt;\n&nbsp;pthread_t storID[10];&lt;BR&gt;\n&nbsp;void * &nbsp;&nbsp;&nbsp;retnMsg[1=\r\n0];&lt;BR&gt;\n&nbsp;pthread_t * ttt;&lt;BR&gt;\n&nbsp;const pthread_attr_t * att =3D 0;&lt;=\r\nBR&gt;\n&nbsp;void *tArgs =3D 0;&lt;BR&gt;\n&nbsp;tArgs =3D &amp;gI;&lt;BR&gt;\n&nbsp;bool do=\r\nThreads =3D true;&lt;BR&gt;\n&lt;BR&gt;\nXML_Node *xc =3D get_XML_File(&quot;gri30.xml&qu=\r\not;);&lt;BR&gt;\n&nbsp;XML_Node * const xs =3D xc-&gt;findNameID(&quot;phase&quot;=\r\n, &quot;gri30_multi&quot;);&lt;BR&gt;\n&lt;BR&gt;\nTransportFactory * transFac =3D Transp=\r\nortFactory::factory();&lt;BR&gt;\n&nbsp;ThermoPhase *tp =3D newPhase(*xs);&lt;BR&gt;\n&nb=\r\nsp;for (int i =3D 0; i &lt; NUM_THREADS; i++) {&lt;BR&gt;\n&nbsp;struct pTran *rrr=\r\n =3D &amp;ptran[i];&lt;BR&gt;\n&nbsp;rrr-&gt;tpThread =3D tp-&gt;duplMyselfAsTherm=\r\noPhase();&lt;BR&gt;\n&nbsp;IdealGasPhase *thermoP =3D dynamic_cast &lt;IdealGasPha=\r\nse *&gt; (rrr-&gt;tpThread);&lt;BR&gt;\n&nbsp;rrr-&gt;p1Thread =3D transFac-&gt;ne=\r\nwTransport(&quot;Multi&quot;, thermoP);&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&lt;BR&gt;\nclockWC tickTo=\r\nck;&lt;BR&gt;\n&nbsp;int jTemp =3D 0;&lt;BR&gt;\n&nbsp;do {&lt;BR&gt;\n&nbsp;if (!doThreads) {&lt;B=\r\nR&gt;\n&nbsp;for (int i =3D 0; i &lt; NUM_THREADS; i++) {&lt;BR&gt;\n&nbsp;ptran[i].iT=\r\nemp =3D jTemp;&lt;BR&gt;\n&nbsp;ptran[i].tpBase =3D tp;&lt;BR&gt;\n&nbsp;ptran[i].tfBase =\r\n=3D transFac;&lt;BR&gt;\n&nbsp;startThread((void *)&amp;ptran[i]);&lt;BR&gt;\n&nbsp;jTemp=\r\n++;&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&nbsp;} else {&lt;BR&gt;\n&nbsp;for (int i =3D 0; i &lt; NUM_T=\r\nHREADS; i++) {&lt;BR&gt;\n&nbsp;ptran[i].iTemp =3D jTemp;&lt;BR&gt;\n&nbsp;ptran[i].tpBas=\r\ne =3D tp;&lt;BR&gt;\n&nbsp;ptran[i].tfBase =3D transFac;&lt;BR&gt;\n&lt;BR&gt;\nint en =3D pthre=\r\nad_create(&amp;storID[i], att, &amp;startThread, (void *)&amp;ptran[i]);&lt;BR=\r\n&gt;\n&nbsp;if (en !=3D 0) {&lt;BR&gt;\n&nbsp;printf(&quot;Error condition from pthrea=\r\nd_create(): %d&#92;n&quot;, en);&lt;BR&gt;\n&nbsp;exit(-1);&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&nbsp;//pr=\r\nintf(&quot;new thead id =3D %ld&#92;n&quot;, storID[i]);&lt;BR&gt;\n&nbsp;jTemp++;&lt;BR&gt;=\r\n\n&nbsp;}&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&nbsp;if (doThreads) {&lt;BR&gt;\n&nbsp;for (int i =3D 0;=\r\n i &lt; NUM_THREADS; i++) {&lt;BR&gt;\n&nbsp;ttt =3D &amp;storID[i];&lt;BR&gt;\n&nbsp;int=\r\n rc =3D pthread_join(storID[i], &amp;(retnMsg[i]));&lt;BR&gt;\n&nbsp;if (rc !=3D 0=\r\n) {&lt;BR&gt;\n&nbsp;printf(&quot;Error condition from pthread_jon(): %d&#92;n&quot;, =\r\nrc);&lt;BR&gt;\n&nbsp;exit(-1);&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&nbsp;//printf(&quot;returned from=\r\n thread %ld&#92;n&quot;, storID[i]);&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&lt;BR&gt;\n} while (=\r\njTemp &lt; NUM_TEMPS);&lt;BR&gt;\n&nbsp;double tt =3D tickTock.secondsWC();&lt;BR&gt;\n&lt;B=\r\nR&gt;\nstd::cout &lt;&lt; &quot;Thermal conductivities as a function of tempera=\r\nture:&#92;n&quot;;&lt;BR&gt;\n&nbsp;for (int j =3D 0; j &lt; &nbsp;NUM_TEMPS; j++) {&lt;B=\r\nR&gt;\n&nbsp;std::cout &lt;&lt; 300.+5.*j &lt;&lt;&quot; &#92;t &quot; &lt;&lt; lam=\r\nbda[j] &lt;&lt; std::endl;&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&nbsp;printf(&quot;elapsed time =\r\n=3D %g&#92;n&quot;, tt);&lt;BR&gt;\n&nbsp;pthread_exit(NULL);&lt;BR&gt;\n&nbsp;return 0;&lt;BR&gt;\n=\r\n}&lt;BR&gt;\n&lt;BR&gt;\nHarry Moffat &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=\r\nsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=\r\nsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(w) (505) 84=\r\n4-6912&lt;BR&gt;\nNanoscale and Reactive Processes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&=\r\nnbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f) &nbsp;&nbsp;(505) 844-8251&lt;BR&gt;\nSandi=\r\na National Laboratories &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=\r\nsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nb=\r\nsp;&nbsp;hkmoffa@... &lt;a href=3D&quot;mailto:hkmoffa%40sandia.gov&quot;&gt;&lt;mai=\r\nlto:hkmoffa%40sandia.gov&gt;&lt;/a&gt; &lt;BR&gt;\nP. O. Box 5800-0836&lt;BR&gt;\nAlbuquerque, =\r\nNM 87185-0836&lt;BR&gt;\n&lt;BR&gt;\n-----Original Message-----&lt;BR&gt;\nFrom: cantera@yahoogr=\r\noups.com &lt;a href=3D&quot;mailto:cantera%40yahoogroups.com&quot;&gt;&lt;mailto:cantera%40=\r\nyahoogroups.com&gt;&lt;/a&gt; &nbsp;[&lt;a href=3D&quot;mailto:cantera@yahoogroups.com&quot;&gt;m=\r\nailto:cantera@yahoogroups.com&lt;/a&gt; &lt;a href=3D&quot;mailto:cantera%40yahoogroups.c=\r\nom&quot;&gt;&lt;mailto:cantera%40yahoogroups.com&gt;&lt;/a&gt; ] On Behalf Of Ray Speth&lt;B=\r\nR&gt;\nSent: Saturday, March 22, 2008 1:25 PM&lt;BR&gt;\nTo: cantera@yahoogroups.com &lt;=\r\na href=3D&quot;mailto:cantera%40yahoogroups.com&quot;&gt;&lt;mailto:cantera%40yahoogroup=\r\ns.com&gt;&lt;/a&gt; &lt;BR&gt;\nSubject: [cantera] Thread safety of MultiTransport&lt;BR&gt;\n&lt;=\r\nBR&gt;\nHi,&lt;BR&gt;\n&lt;BR&gt;\nI have been having some issues using objects of class Mult=\r\niTransport in a multithreaded application. Specifically, I am having troubl=\r\ne with the functions thermalConductivity and get thermalDiffCoeffs, which s=\r\neem to be the only two functions which involve calls to solveLMatrixEquatio=\r\nn. I have included below an example program that experiences the problem. T=\r\nhe error reported is (usually)&lt;BR&gt;\n&lt;BR&gt;\nterminate called after throwing an =\r\ninstance of &#39;Cantera::CanteraError&#39;&lt;BR&gt;\n&lt;BR&gt;\nIf the call to omp_set_num_thr=\r\neads(2) is changed to omp_set_num_threads(1), the program works fine. This =\r\nis on a 64-bit Linux machine, using GCC 4.2. I have built Cantera with the =\r\nThread-safe option turned on. Is the issue with these functions, or is ther=\r\ne something else I need to do to be able to use Multitransport objects in a=\r\n parallel code?&lt;BR&gt;\n&lt;BR&gt;\nAny help in resolving this would be greatly apprec=\r\niated.&lt;BR&gt;\n&lt;BR&gt;\n----------&lt;BR&gt;\n&lt;BR&gt;\n#include &lt;cantera/Cantera.h&gt;&lt;BR&gt;\n=\r\n#include &lt;cantera/kernel/IdealGasPhase.h&gt; #include &lt;cantera/transp=\r\nort.h&gt; #include &lt;cantera/thermo.h&gt; #include &lt;omp.h&gt; #include=\r\n &lt;vector&gt;&lt;BR&gt;\n&lt;BR&gt;\nusing namespace Cantera;&lt;BR&gt;\n&lt;BR&gt;\nvoid omptest(voi=\r\nd)&lt;BR&gt;\n{&lt;BR&gt;\n&nbsp;int N =3D 10;&lt;BR&gt;\n&nbsp;omp_set_num_threads(2);&lt;BR&gt;\n&lt;BR&gt;=\r\n\nXML_Node *xc =3D get_XML_File(&quot;gri30.xml&quot;);&lt;BR&gt;\n&nbsp;XML_Node *=\r\n const xs =3D xc-&gt;findNameID(&quot;phase&quot;, &quot;gri30_multi&quot;)=\r\n;&lt;BR&gt;\n&lt;BR&gt;\nstd::vector&lt;IdealGasPhase*&gt; thermoP(N);&lt;BR&gt;\n&nbsp;std::vec=\r\ntor&lt;MultiTransport*&gt; transportP(N);&lt;BR&gt;\n&lt;BR&gt;\nTransportFactory* transF=\r\nac =3D TransportFactory::factory();&lt;BR&gt;\n&lt;BR&gt;\nfor (int i=3D0; i&lt;N; i++) {=\r\n&lt;BR&gt;\n&nbsp;ThermoPhase* tp =3D newPhase(*xs);&lt;BR&gt;\n&nbsp;thermoP[i] =3D dyna=\r\nmic_cast &lt;IdealGasPhase*&gt;(tp);&lt;BR&gt;\n&nbsp;Transport* p1 =3D transFac-&=\r\ngt;newTransport(&quot;Multi&quot;,thermoP[i]);&lt;BR&gt;\n&nbsp;transportP[i] =3D =\r\ndynamic_cast &lt;MultiTransport*&gt;(p1);&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&lt;BR&gt;\n#pragma omp =\r\nparallel for&lt;BR&gt;\n&nbsp;for (int i=3D0; i&lt;N; i++) {&lt;BR&gt;\n&nbsp;thermoP[i]-=\r\n&gt;setState_TPY(300+50*i,OneAtm,&quot;N2:3.76, O2:1.0&quot;);&lt;BR&gt;\n&nbsp;}&lt;=\r\nBR&gt;\n&lt;BR&gt;\nstd::vector&lt;double&gt; lambda(N);&lt;BR&gt;\n&lt;BR&gt;\n#pragma omp parallel=\r\n for&lt;BR&gt;\n&nbsp;for (int i=3D0; i&lt;N; i++) {&lt;BR&gt;\n&nbsp;lambda[i] =3D trans=\r\nportP[i]-&gt;thermalConductivity();&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n&lt;BR&gt;\nfor (int i=3D0; i&=\r\nlt;N; i++) {&lt;BR&gt;\n&nbsp;std::cout &lt;&lt; lambda[i] &lt;&lt; std::endl;&lt;BR&gt;=\r\n\n&nbsp;}&lt;BR&gt;\n}&lt;BR&gt;\n&lt;BR&gt;\nint main(int argc, char** argv)&lt;BR&gt;\n{&lt;BR&gt;\n&nbsp;try=\r\n {&lt;BR&gt;\n&nbsp;omptest();&lt;BR&gt;\n&nbsp;} catch (CanteraError) {&lt;BR&gt;\n&nbsp;showEr=\r\nrors(cout);&lt;BR&gt;\n&nbsp;}&lt;BR&gt;\n}&lt;BR&gt;\n&lt;BR&gt;\n------------------------------------=\r\n&lt;BR&gt;\n&lt;BR&gt;\nYahoo! Groups Links&lt;BR&gt;\n&lt;BR&gt;\n&nbsp;&lt;BR&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;=\r\nFONT COLOR=3D&quot;#FFFFFF&quot;&gt;&lt;BR&gt;\n&lt;/FONT&gt;&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/BLOCKQUOTE&gt;&lt;FONT FACE=3D=\r\n&quot;Verdana, Helvetica, Arial&quot;&gt;&lt;SPAN STYLE=3D&#39;font-size:12.0px&#39;&gt;&lt;BR&gt;\n&lt;/SPAN&gt;&lt;/=\r\nFONT&gt;\n&lt;/BODY&gt;\n&lt;/HTML&gt;\n\n\r\n--B_3289406261_17003--\r\n\n"}}