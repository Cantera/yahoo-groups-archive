{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":44728387,"authorName":"David Goodwin","from":"David Goodwin &lt;dgoodwin@...&gt;","profile":"dggoodwin","replyTo":"LIST","senderId":"kC38Ap2MZMAasGBDMG_BA4Ls6u5qkmY9zMo7EXo3J6kMhR_cGuYOgGnhuQHLqSKoWtmrOCA76DB8gHgmMSP51-KGMpPjT1RWw2vp","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [cantera] Virtual method warnings","postDate":"1165089279","msgId":1436,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDA4QTk1RjA4LTQzRjItNDNBRi04NzA4LUMzNTRCQTk0MDZGMUBjYWx0ZWNoLmVkdT4=","inReplyToHeader":"PEMxOTQ2QjgyLjM3MzAlc3Bkb21pbkBzYW5kaWEuZ292Pg==","referencesHeader":"PEMxOTQ2QjgyLjM3MzAlc3Bkb21pbkBzYW5kaWEuZ292Pg=="},"prevInTopic":1434,"nextInTopic":0,"prevInTime":1435,"nextInTime":1437,"topicId":1434,"numMessagesInTopic":2,"msgSnippet":"Stefan, The problem is that some old code that should have been removed from Cantera was still present.  Class SpeciesThermo1 is no longer used within Cantera.","rawEmail":"Return-Path: &lt;dgoodwin@...&gt;\r\nX-Sender: dgoodwin@...\r\nX-Apparently-To: cantera@yahoogroups.com\r\nReceived: (qmail 71063 invoked from network); 2 Dec 2006 19:54:55 -0000\r\nReceived: from unknown (66.218.67.34)\n  by m21.grp.scd.yahoo.com with QMQP; 2 Dec 2006 19:54:55 -0000\r\nReceived: from unknown (HELO outgoing-mail.its.caltech.edu) (131.215.239.19)\n  by mta8.grp.scd.yahoo.com with SMTP; 2 Dec 2006 19:54:54 -0000\r\nReceived: from earth-dog.caltech.edu (earth-dog [192.168.1.3])\n\tby earth-ox-postvirus (Postfix) with ESMTP id 8B85010A10E\n\tfor &lt;cantera@yahoogroups.com&gt;; Sat,  2 Dec 2006 11:54:44 -0800 (PST)\r\nReceived: from [10.0.1.4] (charter-243-007.caltech.edu [131.215.243.7])\n\tby wood-ox.its.caltech.edu (Postfix) with ESMTP id 4EF032EEDA\n\tfor &lt;cantera@yahoogroups.com&gt;; Sat,  2 Dec 2006 11:54:41 -0800 (PST)\r\nMime-Version: 1.0 (Apple Message framework v752.2)\r\nIn-Reply-To: &lt;C1946B82.3730%spdomin@...&gt;\r\nReferences: &lt;C1946B82.3730%spdomin@...&gt;\r\nContent-Type: text/plain; charset=US-ASCII; delsp=yes; format=flowed\r\nMessage-Id: &lt;08A95F08-43F2-43AF-8708-C354BA9406F1@...&gt;\r\nContent-Transfer-Encoding: 7bit\r\nDate: Sat, 2 Dec 2006 11:54:39 -0800\r\nTo: cantera@yahoogroups.com\r\nX-Mailer: Apple Mail (2.752.2)\r\nX-Spam-Scanned: at Caltech-ITS on earth-dog by amavisd-2.3.3 \r\nX-eGroups-Msg-Info: 1:0:0:0\r\nFrom: David Goodwin &lt;dgoodwin@...&gt;\r\nSubject: Re: [cantera] Virtual method warnings\r\nX-Yahoo-Group-Post: member; u=44728387; y=Cr-Y9llJNWABZwX1IV0jdUKgo8AhRNKmfWwV-qVq5wrI\r\nX-Yahoo-Profile: dggoodwin\r\n\r\nStefan,\n\nThe problem is that some old code that should have been removed from  \nCantera was still present.  Class SpeciesThermo1 is no longer used  \nwithin Cantera.  It had been surrounded by #ifdef .... #endif  \nstatements that were supposed to remove it back in version 1.5.5, but  \nat some point these were commented out. Still I don&#39;t see why it is  \ncompiling, since this template should never be instantiated... unless  \nof course some application code is still using this class, which it  \nshouldn&#39;t.  All species thermo managers should be instantiated using  \nSpeciesThermoFactory, instead of calling the constructor directly.\n\nJust to be clear:\n\nIn Cantera, it is never the intent to hide a pure virtual method with  \nan overloaded one with different arguments.  If a method in a base  \nclass is declared pure virtual, then every subclass should define it  \nwith the exact arguments as in the base class method.\n\nBy the way, you had previously pointed out that putting &quot;using  \nnamespace&quot; in headers is a bad idea.  In response, I have removed all  \n&quot;using namespace&quot; statements from Cantera header files.  (As it  \nturned out, a fairly big job!)  This change did not make it into  \nversion 1.7.0, but has been checked in to the CVS repository.\n\nI think you have access to more C++ compilers than I do.  As you  \npoint out, g++ accepts some things that others don&#39;t, so I don&#39;t  \nalways see the errors or warnings.  Your help in tracking these  \nthings down is appreciated!\n\nDave\n\n\n\nOn Nov 30, 2006, at 10:05 AM, spdomin wrote:\n\n&gt; Hi,\n&gt;\n&gt; Let&#39;s talk about a specific warning that I am noting in 1.7.0 and  \n&gt; later\n&gt; about the rules about virtual methods - as in what is and is not\n&gt; allowed/standard...\n&gt;\n&gt; The exact warning we can look towards has to do with a class  \n&gt; SpeciesThermo\n&gt; that defines a pure virtual method,\n&gt;\n&gt; virtual void update(doublereal T,\n&gt;             doublereal* cp_R,\n&gt;             doublereal* h_RT,\n&gt;             doublereal* s_R) const=0;\n&gt;\n&gt; The class SpeciesThermo1, which derives off of SpeciesThermo,  \n&gt; provides an\n&gt; implementation of update,\n&gt;\n&gt; virtual void update(doublereal t, vector_fp& cp_R,\n&gt;             vector_fp& h_RT, vector_fp& s_R) const {\n&gt;             _updateAll(m_thermo.begin(),m_thermo.end(),\n&gt;                 t, cp_R, h_RT, s_R);\n&gt;         }\n&gt;\n&gt; Note that this derived class does not provide a implementation of the\n&gt; SpeciedThermo::update pure virtual method!! So, a few compilers  \n&gt; provide a\n&gt; warning that SpeciesThermo1::update hides SpeciesThermo::update.  \n&gt; Based on\n&gt; what I know, a SpeciesThermo1 object must not ever be created in  \n&gt; Cantera. If\n&gt; one is created, then the compiler should fail.\n&gt;\n&gt; Now, let&#39;s consider the following three simple examples that  \n&gt; overviews the\n&gt; &quot;dos and do nots&quot; of virtual/pure virtual methods...\n&gt;\n&gt; The first example defines a pure virtual method in the base class,\n&gt; shape::volume(double,double,double), while the derived class does not\n&gt; provide an implementation for this signature and provides an  \n&gt; overloaded\n&gt; implementation, circle::volume(). However, the circle object is never\n&gt; created. This example **compiles** on g++ and fails for Sun10 (see  \n&gt; warnings\n&gt; below).\n&gt;\n&gt; The second example is the same as the first, however, creates the  \n&gt; circle\n&gt; object. In this case, neither platform compiles. This indicates  \n&gt; that the\n&gt; pure virtual implementation of a derived class check is not  \n&gt; performed until\n&gt; the compiler knows that a derived class object is instantiated - at  \n&gt; least on\n&gt; g++. Sun seems to always understand that what is being attempted is  \n&gt; bad\n&gt; news.\n&gt;\n&gt; The third example defines a virtual method in the base class,\n&gt; shape::volume(double,double,double), while the derived class does not\n&gt; provide an implementation for this signature and provides an  \n&gt; overloaded\n&gt; implementation, circle::volume(). This code does not compile (see  \n&gt; errors\n&gt; below) unless &quot;using shape::volume&quot; is included in the circle  \n&gt; header. If the\n&gt; &quot;using&quot; is omitted, however, a circle::volume(double,double,double)\n&gt; implementation is provided, well, that&#39;s polymorphysim and all is  \n&gt; well. This\n&gt; is basically what you noted in your last email: provide a default\n&gt; implementation that throws and provide the correct one below and  \n&gt; even a new\n&gt; one with a new signature or return type.\n&gt;\n&gt; These are at least the rules of c++. Note the behavior of example 1  \n&gt; and 2 is\n&gt; platform dependent, however, is not standard...\n&gt;\n&gt; Now, perhaps we can not talk about what is the intent of the  \n&gt; SpeciesThermo1\n&gt; class..\n&gt;\n&gt; Regards,\n&gt;\n&gt; Stefan\n&gt;\n&gt;\n&gt; sass8000(207 )% more hideMeNoPVinDerivedNoEnst.C\n&gt; #include &lt;iostream&gt;\n&gt; #include &lt;fstream&gt;\n&gt;\n&gt; //===========================================\n&gt; //  Class Definition: shape\n&gt; //===========================================\n&gt; // shape\n&gt; //===========================================\n&gt; class shape {\n&gt;\n&gt; public:\n&gt;\n&gt;   // constructor\n&gt;   shape();\n&gt;\n&gt;   // destructor\n&gt;   ~shape();\n&gt;\n&gt;   virtual double volume(double x, double y, double z) = 0;\n&gt;\n&gt; };\n&gt;\n&gt; //----------------------------------------------\n&gt; //----- constructor ----------------------------\n&gt; //----------------------------------------------\n&gt; shape::shape(){\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- destructor ------------------------------\n&gt; //----------------------------------------------\n&gt; shape::~shape(){\n&gt; }\n&gt;\n&gt;\n&gt; //===========================================\n&gt; //  Class Definition: circle\n&gt; //===========================================\n&gt; // circle\n&gt; //===========================================\n&gt; class circle : public shape {\n&gt;\n&gt; public:\n&gt;\n&gt;   // constructor\n&gt;   circle();\n&gt;\n&gt;   // destructor\n&gt;   ~circle();\n&gt;   double radius_;\n&gt;\n&gt;   // over loaded base class virtual method\n&gt;   virtual double volume();\n&gt;\n&gt; };\n&gt;\n&gt; //----------------------------------------------\n&gt; //----- constructor ----------------------------\n&gt; //----------------------------------------------\n&gt; circle::circle() : shape() {\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- destructor ------------------------------\n&gt; //----------------------------------------------\n&gt; circle::~circle(){\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- volume ----------------------------------\n&gt; //----------------------------------------------\n&gt; double circle::volume()\n&gt; {\n&gt;   double pi = 3.14159;\n&gt;   std::cout &lt;&lt; &quot;Now this I can handle - I just assume volume is  \n&gt; area... &quot; &lt;&lt;\n&gt; std::endl;\n&gt;   return pi*radius_*radius_;\n&gt; }\n&gt;\n&gt; int main()\n&gt;\n&gt; {\n&gt;   double volume = 1.0;\n&gt;\n&gt;   std::cout &lt;&lt; &quot;volume &quot; &lt;&lt; volume &lt;&lt; std::endl;\n&gt;\n&gt;   return(EXIT_SUCCESS);\n&gt;\n&gt; }\n&gt; /*\n&gt;   g++ no warnings:\n&gt;\n&gt;     volume 1.0\n&gt;\n&gt;   Sun10:\n&gt;  &quot;hideMeNoPureVirtual.C&quot;, line 54: Warning: circle::volume hides  \n&gt; the virtual\n&gt; function shape::volume(double, double, double).\n&gt;  &quot;hideMeNoPureVirtual.C&quot;, line 84: Error: Cannot create a variable for\n&gt; abstract class circle.\n&gt;  &quot;hideMeNoPureVirtual.C&quot;, line 84: Error:     shape::volume(double,  \n&gt; double,\n&gt; double) has not been overridden.\n&gt;  &quot;hideMeNoPureVirtual.C&quot;, line 84: Error: Cannot create a value of the\n&gt; abstract class circle.\n&gt;  &quot;hideMeNoPureVirtual.C&quot;, line 84: Error:     shape::volume(double,  \n&gt; double,\n&gt; double) has not been overridden.\n&gt;  &quot;hideMeNoPureVirtual.C&quot;, line 88: Error: Too many arguments in  \n&gt; call to\n&gt; &quot;circle::volume()&quot;.\n&gt;\n&gt; */\n&gt;\n&gt; sass8000(210 )% more hideMeNoPVinDerivedWithEnst.C\n&gt; #include &lt;iostream&gt;\n&gt; #include &lt;fstream&gt;\n&gt;\n&gt; //===========================================\n&gt; //  Class Definition: shape\n&gt; //===========================================\n&gt; // shape\n&gt; //===========================================\n&gt; class shape {\n&gt;\n&gt; public:\n&gt;\n&gt;   // constructor\n&gt;   shape();\n&gt;\n&gt;   // destructor\n&gt;   ~shape();\n&gt;\n&gt;   virtual double volume(double x, double y, double z) = 0;\n&gt;\n&gt; };\n&gt;\n&gt; //----------------------------------------------\n&gt; //----- constructor ----------------------------\n&gt; //----------------------------------------------\n&gt; shape::shape(){\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- destructor ------------------------------\n&gt; //----------------------------------------------\n&gt; shape::~shape(){\n&gt; }\n&gt;\n&gt;\n&gt; //===========================================\n&gt; //  Class Definition: circle\n&gt; //===========================================\n&gt; // circle\n&gt; //===========================================\n&gt; class circle : public shape {\n&gt;\n&gt; public:\n&gt;\n&gt;   // constructor\n&gt;   circle();\n&gt;\n&gt;   // destructor\n&gt;   ~circle();\n&gt;   double radius_;\n&gt;\n&gt;   // over loaded base class virtual method\n&gt;   virtual double volume();\n&gt;\n&gt; };\n&gt;\n&gt; //----------------------------------------------\n&gt; //----- constructor ----------------------------\n&gt; //----------------------------------------------\n&gt; circle::circle() : shape() {\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- destructor ------------------------------\n&gt; //----------------------------------------------\n&gt; circle::~circle(){\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- volume ----------------------------------\n&gt; //----------------------------------------------\n&gt; double circle::volume()\n&gt; {\n&gt;   double pi = 3.14159;\n&gt;   std::cout &lt;&lt; &quot;Now this I can handle - I just assume volume is  \n&gt; area... &quot; &lt;&lt;\n&gt; std::endl;\n&gt;   return pi*radius_*radius_;\n&gt; }\n&gt;\n&gt; int main()\n&gt;\n&gt; {\n&gt;   double volume;\n&gt;\n&gt;   circle c1 = circle();\n&gt;   c1.radius_ = 1.0;\n&gt;   volume = c1.volume();\n&gt;\n&gt;   std::cout &lt;&lt; &quot;volume &quot; &lt;&lt; volume &lt;&lt; std::endl;\n&gt;\n&gt;   return(EXIT_SUCCESS);\n&gt;\n&gt; }\n&gt; /*\n&gt;   g++:\n&gt; hideMeNoPVinDerivedWithEnst.C: In function `int main()&#39;:\n&gt; hideMeNoPVinDerivedWithEnst.C:84: error: cannot allocate an object  \n&gt; of type\n&gt; `circle&#39;\n&gt; hideMeNoPVinDerivedWithEnst.C:84: error:   because the following  \n&gt; virtual\n&gt; functions are abstract:\n&gt; hideMeNoPVinDerivedWithEnst.C:19: error:  virtual double\n&gt; shape::volume(double, double, double)\n&gt; hideMeNoPVinDerivedWithEnst.C:84: error: cannot declare variable  \n&gt; `c1&#39; to be\n&gt; of type `circle&#39;\n&gt; hideMeNoPVinDerivedWithEnst.C:84: error:   since type `circle&#39; has  \n&gt; abstract\n&gt; virtual functions\n&gt;\n&gt;   Sun10:\n&gt; &quot;hideMeNoPVinDerivedWithEnst.C&quot;, line 55: Warning: circle::volume  \n&gt; hides the\n&gt; virtual function shape::volume(double, double, double).\n&gt; &quot;hideMeNoPVinDerivedWithEnst.C&quot;, line 84: Error: Cannot create a  \n&gt; variable\n&gt; for abstract class circle.\n&gt; &quot;hideMeNoPVinDerivedWithEnst.C&quot;, line 84: Error:     shape::volume \n&gt; (double,\n&gt; double, double) has not been overridden.\n&gt; &quot;hideMeNoPVinDerivedWithEnst.C&quot;, line 84: Error: Cannot create a  \n&gt; value of\n&gt; the abstract class circle.\n&gt; &quot;hideMeNoPVinDerivedWithEnst.C&quot;, line 84: Error:     shape::volume \n&gt; (double,\n&gt; double, double) has not been overridden.\n&gt;\n&gt; */\n&gt;\n&gt;\n&gt; sass8000(213 )% more  hideMeVirtualUsing.C\n&gt; #include &lt;iostream&gt;\n&gt; #include &lt;fstream&gt;\n&gt;\n&gt; //===========================================\n&gt; //  Class Definition: shape\n&gt; //===========================================\n&gt; // shape\n&gt; //===========================================\n&gt; class shape {\n&gt;\n&gt; public:\n&gt;\n&gt;   // constructor\n&gt;   shape();\n&gt;\n&gt;   // destructor\n&gt;   ~shape();\n&gt;\n&gt;   virtual double volume(double x, double y, double z);\n&gt;\n&gt; };\n&gt;\n&gt; //----------------------------------------------\n&gt; //----- constructor ----------------------------\n&gt; //----------------------------------------------\n&gt; shape::shape(){\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- destructor ------------------------------\n&gt; //----------------------------------------------\n&gt; shape::~shape(){\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- volume ----------------------------------\n&gt; //----------------------------------------------\n&gt; double shape::volume(double x, double y, double z) {\n&gt;\n&gt;  std::cout &lt;&lt; &quot; base class call &quot; &lt;&lt; std::endl;\n&gt;  return x*y*z;\n&gt;\n&gt; }\n&gt;\n&gt;\n&gt; //===========================================\n&gt; //  Class Definition: circle\n&gt; //===========================================\n&gt; // circle\n&gt; //===========================================\n&gt; class circle : public shape {\n&gt;\n&gt; public:\n&gt;\n&gt;   // constructor\n&gt;   circle();\n&gt;\n&gt;   // destructor\n&gt;   ~circle();\n&gt;   double radius_;\n&gt;\n&gt;   using shape::volume;\n&gt;\n&gt;   // overloaded bass class virtual method\n&gt;   virtual double volume();\n&gt;\n&gt; };\n&gt;\n&gt; //----------------------------------------------\n&gt; //----- constructor ----------------------------\n&gt; //----------------------------------------------\n&gt; circle::circle() : shape() {\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- destructor ------------------------------\n&gt; //----------------------------------------------\n&gt; circle::~circle(){\n&gt; }\n&gt;\n&gt; //----------------------------------------------\n&gt; //---- volume ----------------------------------\n&gt; //----------------------------------------------\n&gt; double circle::volume()\n&gt; {\n&gt;\n&gt;   double pi = 3.14159;\n&gt; ::endl;      &lt; &quot;Now this I can handle - I just assume volume is  \n&gt; area... &quot; &lt;&lt;\n&gt; std--More--(64%)\n&gt;   return pi*radius_*radius_;\n&gt; }\n&gt;\n&gt; int main()\n&gt;\n&gt; {\n&gt;   double volumeBaseClass, volumeDerivedClass;\n&gt;\n&gt;   circle c1 = circle();\n&gt;   c1.radius_ = 1.0;\n&gt;\n&gt;   volumeBaseClass = c1.volume(1.,2.,3.);\n&gt;   volumeDerivedClass = c1.volume();\n&gt;\n&gt;   std::cout &lt;&lt; &quot;volume from base    class &quot; &lt;&lt; volumeBaseClass &lt;&lt;  \n&gt; std::endl;\n&gt;   std::cout &lt;&lt; &quot;volume from derived class &quot; &lt;&lt; volumeDerivedClass &lt;&lt;\n&gt; std::endl;\n&gt;\n&gt;   return(EXIT_SUCCESS);\n&gt;\n&gt; }\n&gt; /*\n&gt;  without using::shape::volume;\n&gt;\n&gt;  Sun10:\n&gt; &quot;hideMeVirtualUsing.C&quot;, line 67: Warning: circle::volume hides the  \n&gt; virtual\n&gt; function shape::volume(double, double, double).\n&gt; &quot;hideMeVirtualUsing.C&quot;, line 100: Error: Too many arguments in call to\n&gt; &quot;circle::volume()&quot;.\n&gt;\n&gt;  g++:\n&gt; hideMeVirtualUsing.C: In function `int main()&#39;:\n&gt; hideMeVirtualUsing.C:100: error: no matching function for call to\n&gt; `circle::volume(double, double, double)&#39;\n&gt; hideMeVirtualUsing.C:85: note: candidates are: virtual double\n&gt; circle::volume()\n&gt;\n&gt; When using using::shape::volume; both work...\n&gt;\n&gt; base class call\n&gt; Now this I can handle - I just assume volume is area...\n&gt; volume from base    class 6\n&gt; volume from derived class 3.14159\n&gt;\n&gt; */\n&gt;\n&gt;\n&gt;\n&gt;\n&gt;\n&gt; Yahoo! Groups Links\n&gt;\n&gt;\n&gt;\n\n\n"}}